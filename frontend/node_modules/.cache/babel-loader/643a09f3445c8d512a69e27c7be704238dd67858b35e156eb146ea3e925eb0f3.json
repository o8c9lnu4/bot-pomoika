{"ast":null,"code":"import _slicedToArray from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from './common';\nimport { getTimestampIdentifier } from '../util/timestamp';\nvar FULL_WIDTH = 100;\nvar DEFAULT_OFFSET = 5;\nvar WIDTH_MULTIPLIER = 1.7;\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport var stack = function stack(events, firstWeekday, overlapThreshold) {\n  var handler = getOverlapGroupHandler(firstWeekday); // eslint-disable-next-line max-statements\n\n  return function (day, dayEvents, timed, reset) {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed, reset);\n    }\n    var dayStart = getTimestampIdentifier(day);\n    var visuals = getVisuals(dayEvents, dayStart);\n    var groups = getGroups(visuals, dayStart);\n    var _iterator = _createForOfIteratorHelper(groups),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var group = _step.value;\n        var nodes = [];\n        var _iterator2 = _createForOfIteratorHelper(group.visuals),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var visual = _step2.value;\n            var child = getNode(visual, dayStart);\n            var index = getNextIndex(child, nodes);\n            if (index === false) {\n              var parent = getParent(child, nodes);\n              if (parent) {\n                child.parent = parent;\n                child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));\n                child.index = parent.index + 1;\n                parent.children.push(child);\n              }\n            } else {\n              var _getOverlappingRange = getOverlappingRange(child, nodes, index - 1, index - 1),\n                _getOverlappingRange2 = _slicedToArray(_getOverlappingRange, 1),\n                _parent = _getOverlappingRange2[0];\n              var children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);\n              child.children = children;\n              child.index = index;\n              if (_parent) {\n                child.parent = _parent;\n                child.sibling = hasOverlap(child.start, child.end, _parent.start, addTime(_parent.start, overlapThreshold));\n                _parent.children.push(child);\n              }\n              var _iterator3 = _createForOfIteratorHelper(children),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var grand = _step3.value;\n                  if (grand.parent === _parent) {\n                    grand.parent = child;\n                  }\n                  var grandNext = grand.index - child.index <= 1;\n                  if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n                    grand.sibling = true;\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n            nodes.push(child);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        calculateBounds(nodes, overlapThreshold);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    visuals.sort(function (a, b) {\n      return a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier;\n    });\n    return visuals;\n  };\n};\nfunction calculateBounds(nodes, overlapThreshold) {\n  var _iterator4 = _createForOfIteratorHelper(nodes),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var node = _step4.value;\n      var visual = node.visual,\n        parent = node.parent;\n      var columns = getMaxChildIndex(node) + 1;\n      var spaceLeft = parent ? parent.visual.left : 0;\n      var spaceWidth = FULL_WIDTH - spaceLeft;\n      var offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns);\n      var columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);\n      var columnOffset = spaceWidth / (columns - node.index + 1);\n      var columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;\n      if (parent) {\n        visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;\n      }\n      visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH - visual.left : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\nfunction getColumnWidthMultiplier(node, nodes) {\n  if (!node.children.length) {\n    return 1;\n  }\n  var maxColumn = node.index + nodes.length;\n  var minColumn = node.children.reduce(function (min, c) {\n    return Math.min(min, c.index);\n  }, maxColumn);\n  return minColumn - node.index;\n}\nfunction getOverlappingIndices(node, nodes) {\n  var indices = [];\n  var _iterator5 = _createForOfIteratorHelper(nodes),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var other = _step5.value;\n      if (hasOverlap(node.start, node.end, other.start, other.end)) {\n        indices.push(other.index);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return indices;\n}\nfunction getNextIndex(node, nodes) {\n  var indices = getOverlappingIndices(node, nodes);\n  indices.sort();\n  for (var i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i;\n    }\n  }\n  return false;\n}\nfunction getOverlappingRange(node, nodes, indexMin, indexMax) {\n  var returnFirstColumn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var overlapping = [];\n  var _iterator6 = _createForOfIteratorHelper(nodes),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var other = _step6.value;\n      if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n        overlapping.push(other);\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  if (returnFirstColumn && overlapping.length > 0) {\n    var first = overlapping.reduce(function (min, n) {\n      return Math.min(min, n.index);\n    }, overlapping[0].index);\n    return overlapping.filter(function (n) {\n      return n.index === first;\n    });\n  }\n  return overlapping;\n}\nfunction getParent(node, nodes) {\n  var parent = null;\n  var _iterator7 = _createForOfIteratorHelper(nodes),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var other = _step7.value;\n      if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n        parent = other;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return parent;\n}\nfunction hasFullWidth(node, nodes, overlapThreshold) {\n  var _iterator8 = _createForOfIteratorHelper(nodes),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var other = _step8.value;\n      if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return true;\n}\nfunction getGroups(visuals, dayStart) {\n  var groups = [];\n  var _iterator9 = _createForOfIteratorHelper(visuals),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var visual = _step9.value;\n      var _getNormalizedRange = getNormalizedRange(visual.event, dayStart),\n        _getNormalizedRange2 = _slicedToArray(_getNormalizedRange, 2),\n        start = _getNormalizedRange2[0],\n        end = _getNormalizedRange2[1];\n      var added = false;\n      var _iterator10 = _createForOfIteratorHelper(groups),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var group = _step10.value;\n          if (hasOverlap(start, end, group.start, group.end)) {\n            group.visuals.push(visual);\n            group.end = Math.max(group.end, end);\n            added = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      if (!added) {\n        groups.push({\n          start: start,\n          end: end,\n          visuals: [visual]\n        });\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return groups;\n}\nfunction getNode(visual, dayStart) {\n  var _getNormalizedRange3 = getNormalizedRange(visual.event, dayStart),\n    _getNormalizedRange4 = _slicedToArray(_getNormalizedRange3, 2),\n    start = _getNormalizedRange4[0],\n    end = _getNormalizedRange4[1];\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual: visual,\n    start: start,\n    end: end,\n    children: []\n  };\n}\nfunction getMaxChildIndex(node) {\n  var max = node.index;\n  var _iterator11 = _createForOfIteratorHelper(node.children),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var child = _step11.value;\n      var childMax = getMaxChildIndex(child);\n      if (childMax > max) {\n        max = childMax;\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return max;\n}\nfunction addTime(identifier, minutes) {\n  var removeMinutes = identifier % 100;\n  var totalMinutes = removeMinutes + minutes;\n  var addHours = Math.floor(totalMinutes / 60);\n  var addMinutes = totalMinutes % 60;\n  return identifier - removeMinutes + addHours * 100 + addMinutes;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}