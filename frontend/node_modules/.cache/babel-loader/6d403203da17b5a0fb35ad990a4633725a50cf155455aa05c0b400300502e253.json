{"ast":null,"code":"import _typeof from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _objectSpread from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n// Styles\nimport \"../../../../src/components/VCalendar/mixins/calendar-with-events.sass\"; // Directives\n\nimport ripple from '../../../directives/ripple'; // Mixins\n\nimport CalendarBase from './calendar-base'; // Util\n\nimport props from '../util/props';\nimport { CalendarEventOverlapModes } from '../modes';\nimport { getDayIdentifier, diffMinutes } from '../util/timestamp';\nimport { parseEvent as _parseEvent, isEventStart, isEventOn, isEventOverlapping, isEventHiddenOn } from '../util/events';\nvar WIDTH_FULL = 100;\nvar WIDTH_START = 95;\nvar MINUTES_IN_DAY = 1440;\n/* @vue/component */\n\nexport default CalendarBase.extend({\n  name: 'calendar-with-events',\n  directives: {\n    ripple: ripple\n  },\n  props: _objectSpread(_objectSpread(_objectSpread({}, props.events), props.calendar), props.category),\n  computed: {\n    noEvents: function noEvents() {\n      return this.events.length === 0;\n    },\n    parsedEvents: function parsedEvents() {\n      return this.events.map(this.parseEvent);\n    },\n    parsedEventOverlapThreshold: function parsedEventOverlapThreshold() {\n      return parseInt(this.eventOverlapThreshold);\n    },\n    eventTimedFunction: function eventTimedFunction() {\n      var _this = this;\n      return typeof this.eventTimed === 'function' ? this.eventTimed : function (event) {\n        return !!event[_this.eventTimed];\n      };\n    },\n    eventCategoryFunction: function eventCategoryFunction() {\n      var _this2 = this;\n      return typeof this.eventCategory === 'function' ? this.eventCategory : function (event) {\n        return event[_this2.eventCategory];\n      };\n    },\n    eventTextColorFunction: function eventTextColorFunction() {\n      var _this3 = this;\n      return typeof this.eventTextColor === 'function' ? this.eventTextColor : function () {\n        return _this3.eventTextColor;\n      };\n    },\n    eventNameFunction: function eventNameFunction() {\n      var _this4 = this;\n      return typeof this.eventName === 'function' ? this.eventName : function (event, timedEvent) {\n        return event.input[_this4.eventName] || '';\n      };\n    },\n    eventModeFunction: function eventModeFunction() {\n      return typeof this.eventOverlapMode === 'function' ? this.eventOverlapMode : CalendarEventOverlapModes[this.eventOverlapMode];\n    },\n    eventWeekdays: function eventWeekdays() {\n      return this.parsedWeekdays;\n    },\n    categoryMode: function categoryMode() {\n      return this.type === 'category';\n    }\n  },\n  methods: {\n    eventColorFunction: function eventColorFunction(e) {\n      return typeof this.eventColor === 'function' ? this.eventColor(e) : e.color || this.eventColor;\n    },\n    parseEvent: function parseEvent(input) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _parseEvent(input, index, this.eventStart, this.eventEnd, this.eventTimedFunction(input), this.categoryMode ? this.eventCategoryFunction(input) : false);\n    },\n    formatTime: function formatTime(withTime, ampm) {\n      var formatter = this.getFormatter({\n        timeZone: 'UTC',\n        hour: 'numeric',\n        minute: withTime.minute > 0 ? 'numeric' : undefined\n      });\n      return formatter(withTime, true);\n    },\n    updateEventVisibility: function updateEventVisibility() {\n      if (this.noEvents || !this.eventMore) {\n        return;\n      }\n      var eventHeight = this.eventHeight;\n      var eventsMap = this.getEventsMap();\n      for (var date in eventsMap) {\n        var _eventsMap$date = eventsMap[date],\n          parent = _eventsMap$date.parent,\n          events = _eventsMap$date.events,\n          more = _eventsMap$date.more;\n        if (!more) {\n          break;\n        }\n        var parentBounds = parent.getBoundingClientRect();\n        var last = events.length - 1;\n        var eventsSorted = events.map(function (event) {\n          return {\n            event: event,\n            bottom: event.getBoundingClientRect().bottom\n          };\n        }).sort(function (a, b) {\n          return a.bottom - b.bottom;\n        });\n        var hidden = 0;\n        for (var i = 0; i <= last; i++) {\n          var bottom = eventsSorted[i].bottom;\n          var hide = i === last ? bottom > parentBounds.bottom : bottom + eventHeight > parentBounds.bottom;\n          if (hide) {\n            eventsSorted[i].event.style.display = 'none';\n            hidden++;\n          }\n        }\n        if (hidden) {\n          more.style.display = '';\n          more.innerHTML = this.$vuetify.lang.t(this.eventMoreText, hidden);\n        } else {\n          more.style.display = 'none';\n        }\n      }\n    },\n    getEventsMap: function getEventsMap() {\n      var eventsMap = {};\n      var elements = this.$refs.events;\n      if (!elements || !elements.forEach) {\n        return eventsMap;\n      }\n      elements.forEach(function (el) {\n        var date = el.getAttribute('data-date');\n        if (el.parentElement && date) {\n          if (!(date in eventsMap)) {\n            eventsMap[date] = {\n              parent: el.parentElement,\n              more: null,\n              events: []\n            };\n          }\n          if (el.getAttribute('data-more')) {\n            eventsMap[date].more = el;\n          } else {\n            eventsMap[date].events.push(el);\n            el.style.display = '';\n          }\n        }\n      });\n      return eventsMap;\n    },\n    genDayEvent: function genDayEvent(_ref, day) {\n      var event = _ref.event;\n      var eventHeight = this.eventHeight;\n      var eventMarginBottom = this.eventMarginBottom;\n      var dayIdentifier = getDayIdentifier(day);\n      var week = day.week;\n      var start = dayIdentifier === event.startIdentifier;\n      var end = dayIdentifier === event.endIdentifier;\n      var width = WIDTH_START;\n      if (!this.categoryMode) {\n        for (var i = day.index + 1; i < week.length; i++) {\n          var weekdayIdentifier = getDayIdentifier(week[i]);\n          if (event.endIdentifier >= weekdayIdentifier) {\n            width += WIDTH_FULL;\n            end = end || weekdayIdentifier === event.endIdentifier;\n          } else {\n            end = true;\n            break;\n          }\n        }\n      }\n      var scope = {\n        eventParsed: event,\n        day: day,\n        start: start,\n        end: end,\n        timed: false\n      };\n      return this.genEvent(event, scope, false, {\n        staticClass: 'v-event',\n        \"class\": {\n          'v-event-start': start,\n          'v-event-end': end\n        },\n        style: {\n          height: \"\".concat(eventHeight, \"px\"),\n          width: \"\".concat(width, \"%\"),\n          'margin-bottom': \"\".concat(eventMarginBottom, \"px\")\n        },\n        attrs: {\n          'data-date': day.date\n        },\n        key: event.index,\n        ref: 'events',\n        refInFor: true\n      });\n    },\n    genTimedEvent: function genTimedEvent(_ref2, day) {\n      var event = _ref2.event,\n        left = _ref2.left,\n        width = _ref2.width;\n      if (day.timeDelta(event.end) < 0 || day.timeDelta(event.start) >= 1 || isEventHiddenOn(event, day)) {\n        return false;\n      }\n      var dayIdentifier = getDayIdentifier(day);\n      var start = event.startIdentifier >= dayIdentifier;\n      var end = event.endIdentifier > dayIdentifier;\n      var top = start ? day.timeToY(event.start) : 0;\n      var bottom = end ? day.timeToY(MINUTES_IN_DAY) : day.timeToY(event.end);\n      var height = Math.max(this.eventHeight, bottom - top);\n      var scope = {\n        eventParsed: event,\n        day: day,\n        start: start,\n        end: end,\n        timed: true\n      };\n      return this.genEvent(event, scope, true, {\n        staticClass: 'v-event-timed',\n        style: {\n          top: \"\".concat(top, \"px\"),\n          height: \"\".concat(height, \"px\"),\n          left: \"\".concat(left, \"%\"),\n          width: \"\".concat(width, \"%\")\n        }\n      });\n    },\n    genEvent: function genEvent(event, scopeInput, timedEvent, data) {\n      var _this5 = this;\n      var _a;\n      var slot = this.$scopedSlots.event;\n      var text = this.eventTextColorFunction(event.input);\n      var background = this.eventColorFunction(event.input);\n      var overlapsNoon = event.start.hour < 12 && event.end.hour >= 12;\n      var singline = diffMinutes(event.start, event.end) <= this.parsedEventOverlapThreshold;\n      var formatTime = this.formatTime;\n      var timeSummary = function timeSummary() {\n        return formatTime(event.start, overlapsNoon) + ' - ' + formatTime(event.end, true);\n      };\n      var eventSummary = function eventSummary() {\n        var name = _this5.eventNameFunction(event, timedEvent);\n        if (event.start.hasTime) {\n          if (timedEvent) {\n            var time = timeSummary();\n            var delimiter = singline ? ', ' : _this5.$createElement('br');\n            return _this5.$createElement('span', {\n              staticClass: 'v-event-summary'\n            }, [_this5.$createElement('strong', [name]), delimiter, time]);\n          } else {\n            var _time = formatTime(event.start, true);\n            return _this5.$createElement('span', {\n              staticClass: 'v-event-summary'\n            }, [_this5.$createElement('strong', [_time]), ' ', name]);\n          }\n        }\n        return _this5.$createElement('span', {\n          staticClass: 'v-event-summary'\n        }, [name]);\n      };\n      var scope = _objectSpread(_objectSpread({}, scopeInput), {}, {\n        event: event.input,\n        outside: scopeInput.day.outside,\n        singline: singline,\n        overlapsNoon: overlapsNoon,\n        formatTime: formatTime,\n        timeSummary: timeSummary,\n        eventSummary: eventSummary\n      });\n      return this.$createElement('div', this.setTextColor(text, this.setBackgroundColor(background, _objectSpread({\n        on: this.getDefaultMouseEventHandlers(':event', function (nativeEvent) {\n          return _objectSpread(_objectSpread({}, scope), {}, {\n            nativeEvent: nativeEvent\n          });\n        }),\n        directives: [{\n          name: 'ripple',\n          value: (_a = this.eventRipple) !== null && _a !== void 0 ? _a : true\n        }]\n      }, data))), slot ? slot(scope) : [this.genName(eventSummary)]);\n    },\n    genName: function genName(eventSummary) {\n      return this.$createElement('div', {\n        staticClass: 'pl-1'\n      }, [eventSummary()]);\n    },\n    genPlaceholder: function genPlaceholder(day) {\n      var height = this.eventHeight + this.eventMarginBottom;\n      return this.$createElement('div', {\n        style: {\n          height: \"\".concat(height, \"px\")\n        },\n        attrs: {\n          'data-date': day.date\n        },\n        ref: 'events',\n        refInFor: true\n      });\n    },\n    genMore: function genMore(day) {\n      var _a;\n      var eventHeight = this.eventHeight;\n      var eventMarginBottom = this.eventMarginBottom;\n      return this.$createElement('div', {\n        staticClass: 'v-event-more pl-1',\n        \"class\": {\n          'v-outside': day.outside\n        },\n        attrs: {\n          'data-date': day.date,\n          'data-more': 1\n        },\n        directives: [{\n          name: 'ripple',\n          value: (_a = this.eventRipple) !== null && _a !== void 0 ? _a : true\n        }],\n        on: this.getDefaultMouseEventHandlers(':more', function (nativeEvent) {\n          return _objectSpread({\n            nativeEvent: nativeEvent\n          }, day);\n        }),\n        style: {\n          display: 'none',\n          height: \"\".concat(eventHeight, \"px\"),\n          'margin-bottom': \"\".concat(eventMarginBottom, \"px\")\n        },\n        ref: 'events',\n        refInFor: true\n      });\n    },\n    getVisibleEvents: function getVisibleEvents() {\n      var start = getDayIdentifier(this.days[0]);\n      var end = getDayIdentifier(this.days[this.days.length - 1]);\n      return this.parsedEvents.filter(function (event) {\n        return isEventOverlapping(event, start, end);\n      });\n    },\n    isEventForCategory: function isEventForCategory(event, category) {\n      return !this.categoryMode || _typeof(category) === 'object' && category.categoryName && category.categoryName === event.category || typeof event.category === 'string' && category === event.category || typeof event.category !== 'string' && category === null;\n    },\n    getEventsForDay: function getEventsForDay(day) {\n      var identifier = getDayIdentifier(day);\n      var firstWeekday = this.eventWeekdays[0];\n      return this.parsedEvents.filter(function (event) {\n        return isEventStart(event, day, identifier, firstWeekday);\n      });\n    },\n    getEventsForDayAll: function getEventsForDayAll(day) {\n      var _this6 = this;\n      var identifier = getDayIdentifier(day);\n      var firstWeekday = this.eventWeekdays[0];\n      return this.parsedEvents.filter(function (event) {\n        return event.allDay && (_this6.categoryMode ? isEventOn(event, identifier) : isEventStart(event, day, identifier, firstWeekday)) && _this6.isEventForCategory(event, day.category);\n      });\n    },\n    getEventsForDayTimed: function getEventsForDayTimed(day) {\n      var _this7 = this;\n      var identifier = getDayIdentifier(day);\n      return this.parsedEvents.filter(function (event) {\n        return !event.allDay && isEventOn(event, identifier) && _this7.isEventForCategory(event, day.category);\n      });\n    },\n    getScopedSlots: function getScopedSlots() {\n      var _this8 = this;\n      if (this.noEvents) {\n        return _objectSpread({}, this.$scopedSlots);\n      }\n      var mode = this.eventModeFunction(this.parsedEvents, this.eventWeekdays[0], this.parsedEventOverlapThreshold);\n      var isNode = function isNode(input) {\n        return !!input;\n      };\n      var getSlotChildren = function getSlotChildren(day, getter, mapper, timed) {\n        var events = getter(day);\n        var visuals = mode(day, events, timed, _this8.categoryMode);\n        if (timed) {\n          return visuals.map(function (visual) {\n            return mapper(visual, day);\n          }).filter(isNode);\n        }\n        var children = [];\n        visuals.forEach(function (visual, index) {\n          while (children.length < visual.column) {\n            children.push(_this8.genPlaceholder(day));\n          }\n          var mapped = mapper(visual, day);\n          if (mapped) {\n            children.push(mapped);\n          }\n        });\n        return children;\n      };\n      var slots = this.$scopedSlots;\n      var slotDay = slots.day;\n      var slotDayHeader = slots['day-header'];\n      var slotDayBody = slots['day-body'];\n      return _objectSpread(_objectSpread({}, slots), {}, {\n        day: function day(_day) {\n          var children = getSlotChildren(_day, _this8.getEventsForDay, _this8.genDayEvent, false);\n          if (children && children.length > 0 && _this8.eventMore) {\n            children.push(_this8.genMore(_day));\n          }\n          if (slotDay) {\n            var slot = slotDay(_day);\n            if (slot) {\n              children = children ? children.concat(slot) : slot;\n            }\n          }\n          return children;\n        },\n        'day-header': function dayHeader(day) {\n          var children = getSlotChildren(day, _this8.getEventsForDayAll, _this8.genDayEvent, false);\n          if (slotDayHeader) {\n            var slot = slotDayHeader(day);\n            if (slot) {\n              children = children ? children.concat(slot) : slot;\n            }\n          }\n          return children;\n        },\n        'day-body': function dayBody(day) {\n          var events = getSlotChildren(day, _this8.getEventsForDayTimed, _this8.genTimedEvent, true);\n          var children = [_this8.$createElement('div', {\n            staticClass: 'v-event-timed-container'\n          }, events)];\n          if (slotDayBody) {\n            var slot = slotDayBody(day);\n            if (slot) {\n              children = children.concat(slot);\n            }\n          }\n          return children;\n        }\n      });\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}