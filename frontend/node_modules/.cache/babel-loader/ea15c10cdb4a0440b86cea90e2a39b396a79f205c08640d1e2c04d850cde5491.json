{"ast":null,"code":"import _slicedToArray from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n// Styles\nimport \"../../../src/components/VTreeview/VTreeview.sass\"; // Components\n\nimport VTreeviewNode, { VTreeviewNodeProps } from './VTreeviewNode'; // Mixins\n\nimport Themeable from '../../mixins/themeable';\nimport { provide as RegistrableProvide } from '../../mixins/registrable'; // Utils\n\nimport { arrayDiff, deepEqual, getObjectValueByPath } from '../../util/helpers';\nimport mixins from '../../util/mixins';\nimport { consoleWarn } from '../../util/console';\nimport { filterTreeItems, filterTreeItem } from './util/filterTreeItems';\nexport default mixins(RegistrableProvide('treeview'), Themeable\n/* @vue/component */).extend({\n  name: 'v-treeview',\n  provide: function provide() {\n    return {\n      treeview: this\n    };\n  },\n  props: _objectSpread({\n    active: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    dense: Boolean,\n    disabled: Boolean,\n    filter: Function,\n    hoverable: Boolean,\n    items: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    multipleActive: Boolean,\n    open: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    openAll: Boolean,\n    returnObject: {\n      type: Boolean,\n      \"default\": false // TODO: Should be true in next major\n    },\n    search: String,\n    value: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    }\n  }, VTreeviewNodeProps),\n  data: function data() {\n    return {\n      level: -1,\n      activeCache: new Set(),\n      nodes: {},\n      openCache: new Set(),\n      selectedCache: new Set()\n    };\n  },\n  computed: {\n    excludedItems: function excludedItems() {\n      var excluded = new Set();\n      if (!this.search) return excluded;\n      for (var i = 0; i < this.items.length; i++) {\n        filterTreeItems(this.filter || filterTreeItem, this.items[i], this.search, this.itemKey, this.itemText, this.itemChildren, excluded);\n      }\n      return excluded;\n    }\n  },\n  watch: {\n    items: {\n      handler: function handler() {\n        var _this = this;\n        var oldKeys = Object.keys(this.nodes).map(function (k) {\n          return getObjectValueByPath(_this.nodes[k].item, _this.itemKey);\n        });\n        var newKeys = this.getKeys(this.items);\n        var diff = arrayDiff(newKeys, oldKeys); // We only want to do stuff if items have changed\n\n        if (!diff.length && newKeys.length < oldKeys.length) return; // If nodes are removed we need to clear them from this.nodes\n\n        diff.forEach(function (k) {\n          return delete _this.nodes[k];\n        });\n        var oldSelectedCache = _toConsumableArray(this.selectedCache);\n        this.selectedCache = new Set();\n        this.activeCache = new Set();\n        this.openCache = new Set();\n        this.buildTree(this.items); // Only emit selected if selection has changed\n        // as a result of items changing. This fixes a\n        // potential double emit when selecting a node\n        // with dynamic children\n\n        if (!deepEqual(oldSelectedCache, _toConsumableArray(this.selectedCache))) this.emitSelected();\n      },\n      deep: true\n    },\n    active: function active(value) {\n      this.handleNodeCacheWatcher(value, this.activeCache, this.updateActive, this.emitActive);\n    },\n    value: function value(_value) {\n      this.handleNodeCacheWatcher(_value, this.selectedCache, this.updateSelected, this.emitSelected);\n    },\n    open: function open(value) {\n      this.handleNodeCacheWatcher(value, this.openCache, this.updateOpen, this.emitOpen);\n    }\n  },\n  created: function created() {\n    var _this2 = this;\n    var getValue = function getValue(key) {\n      return _this2.returnObject ? getObjectValueByPath(key, _this2.itemKey) : key;\n    };\n    this.buildTree(this.items);\n    var _iterator = _createForOfIteratorHelper(this.value.map(getValue)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var value = _step.value;\n        this.updateSelected(value, true, true);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(this.active.map(getValue)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var active = _step2.value;\n        this.updateActive(active, true);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n  mounted: function mounted() {\n    var _this3 = this;\n    // Save the developer from themselves\n    if (this.$slots.prepend || this.$slots.append) {\n      consoleWarn('The prepend and append slots require a slot-scope attribute', this);\n    }\n    if (this.openAll) {\n      this.updateAll(true);\n    } else {\n      this.open.forEach(function (key) {\n        return _this3.updateOpen(_this3.returnObject ? getObjectValueByPath(key, _this3.itemKey) : key, true);\n      });\n      this.emitOpen();\n    }\n  },\n  methods: {\n    /** @public */updateAll: function updateAll(value) {\n      var _this4 = this;\n      Object.keys(this.nodes).forEach(function (key) {\n        return _this4.updateOpen(getObjectValueByPath(_this4.nodes[key].item, _this4.itemKey), value);\n      });\n      this.emitOpen();\n    },\n    getKeys: function getKeys(items) {\n      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      for (var i = 0; i < items.length; i++) {\n        var key = getObjectValueByPath(items[i], this.itemKey);\n        keys.push(key);\n        var children = getObjectValueByPath(items[i], this.itemChildren);\n        if (children) {\n          keys.push.apply(keys, _toConsumableArray(this.getKeys(children)));\n        }\n      }\n      return keys;\n    },\n    buildTree: function buildTree(items) {\n      var _this5 = this;\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var _a;\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        var key = getObjectValueByPath(item, this.itemKey);\n        var children = (_a = getObjectValueByPath(item, this.itemChildren)) !== null && _a !== void 0 ? _a : [];\n        var oldNode = this.nodes.hasOwnProperty(key) ? this.nodes[key] : {\n          isSelected: false,\n          isIndeterminate: false,\n          isActive: false,\n          isOpen: false,\n          vnode: null\n        };\n        var node = {\n          vnode: oldNode.vnode,\n          parent: parent,\n          children: children.map(function (c) {\n            return getObjectValueByPath(c, _this5.itemKey);\n          }),\n          item: item\n        };\n        this.buildTree(children, key); // This fixed bug with dynamic children resetting selected parent state\n\n        if (this.selectionType !== 'independent' && parent !== null && !this.nodes.hasOwnProperty(key) && this.nodes.hasOwnProperty(parent)) {\n          node.isSelected = this.nodes[parent].isSelected;\n        } else {\n          node.isSelected = oldNode.isSelected;\n          node.isIndeterminate = oldNode.isIndeterminate;\n        }\n        node.isActive = oldNode.isActive;\n        node.isOpen = oldNode.isOpen;\n        this.nodes[key] = node;\n        if (children.length && this.selectionType !== 'independent') {\n          var _this$calculateState = this.calculateState(key, this.nodes),\n            isSelected = _this$calculateState.isSelected,\n            isIndeterminate = _this$calculateState.isIndeterminate;\n          node.isSelected = isSelected;\n          node.isIndeterminate = isIndeterminate;\n        } // Don't forget to rebuild cache\n\n        if (this.nodes[key].isSelected && (this.selectionType === 'independent' || node.children.length === 0)) this.selectedCache.add(key);\n        if (this.nodes[key].isActive) this.activeCache.add(key);\n        if (this.nodes[key].isOpen) this.openCache.add(key);\n        this.updateVnodeState(key);\n      }\n    },\n    calculateState: function calculateState(node, state) {\n      var children = state[node].children;\n      var counts = children.reduce(function (counts, child) {\n        counts[0] += +Boolean(state[child].isSelected);\n        counts[1] += +Boolean(state[child].isIndeterminate);\n        return counts;\n      }, [0, 0]);\n      var isSelected = !!children.length && counts[0] === children.length;\n      var isIndeterminate = !isSelected && (counts[0] > 0 || counts[1] > 0);\n      return {\n        isSelected: isSelected,\n        isIndeterminate: isIndeterminate\n      };\n    },\n    emitOpen: function emitOpen() {\n      this.emitNodeCache('update:open', this.openCache);\n    },\n    emitSelected: function emitSelected() {\n      this.emitNodeCache('input', this.selectedCache);\n    },\n    emitActive: function emitActive() {\n      this.emitNodeCache('update:active', this.activeCache);\n    },\n    emitNodeCache: function emitNodeCache(event, cache) {\n      var _this6 = this;\n      this.$emit(event, this.returnObject ? _toConsumableArray(cache).map(function (key) {\n        return _this6.nodes[key].item;\n      }) : _toConsumableArray(cache));\n    },\n    handleNodeCacheWatcher: function handleNodeCacheWatcher(value, cache, updateFn, emitFn) {\n      var _this7 = this;\n      value = this.returnObject ? value.map(function (v) {\n        return getObjectValueByPath(v, _this7.itemKey);\n      }) : value;\n      var old = _toConsumableArray(cache);\n      if (deepEqual(old, value)) return;\n      old.forEach(function (key) {\n        return updateFn(key, false);\n      });\n      value.forEach(function (key) {\n        return updateFn(key, true);\n      });\n      emitFn();\n    },\n    getDescendants: function getDescendants(key) {\n      var _descendants;\n      var descendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var children = this.nodes[key].children;\n      (_descendants = descendants).push.apply(_descendants, _toConsumableArray(children));\n      for (var i = 0; i < children.length; i++) {\n        descendants = this.getDescendants(children[i], descendants);\n      }\n      return descendants;\n    },\n    getParents: function getParents(key) {\n      var parent = this.nodes[key].parent;\n      var parents = [];\n      while (parent !== null) {\n        parents.push(parent);\n        parent = this.nodes[parent].parent;\n      }\n      return parents;\n    },\n    register: function register(node) {\n      var key = getObjectValueByPath(node.item, this.itemKey);\n      this.nodes[key].vnode = node;\n      this.updateVnodeState(key);\n    },\n    unregister: function unregister(node) {\n      var key = getObjectValueByPath(node.item, this.itemKey);\n      if (this.nodes[key]) this.nodes[key].vnode = null;\n    },\n    isParent: function isParent(key) {\n      return this.nodes[key].children && this.nodes[key].children.length;\n    },\n    updateActive: function updateActive(key, isActive) {\n      var _this8 = this;\n      if (!this.nodes.hasOwnProperty(key)) return;\n      if (!this.multipleActive) {\n        this.activeCache.forEach(function (active) {\n          _this8.nodes[active].isActive = false;\n          _this8.updateVnodeState(active);\n          _this8.activeCache[\"delete\"](active);\n        });\n      }\n      var node = this.nodes[key];\n      if (!node) return;\n      if (isActive) this.activeCache.add(key);else this.activeCache[\"delete\"](key);\n      node.isActive = isActive;\n      this.updateVnodeState(key);\n    },\n    updateSelected: function updateSelected(key, isSelected) {\n      var isForced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this.nodes.hasOwnProperty(key)) return;\n      var changed = new Map();\n      if (this.selectionType !== 'independent') {\n        var _iterator3 = _createForOfIteratorHelper(this.getDescendants(key)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var descendant = _step3.value;\n            if (!getObjectValueByPath(this.nodes[descendant].item, this.itemDisabled) || isForced) {\n              this.nodes[descendant].isSelected = isSelected;\n              this.nodes[descendant].isIndeterminate = false;\n              changed.set(descendant, isSelected);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        var calculated = this.calculateState(key, this.nodes);\n        this.nodes[key].isSelected = isSelected;\n        this.nodes[key].isIndeterminate = calculated.isIndeterminate;\n        changed.set(key, isSelected);\n        var _iterator4 = _createForOfIteratorHelper(this.getParents(key)),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var parent = _step4.value;\n            var _calculated = this.calculateState(parent, this.nodes);\n            this.nodes[parent].isSelected = _calculated.isSelected;\n            this.nodes[parent].isIndeterminate = _calculated.isIndeterminate;\n            changed.set(parent, _calculated.isSelected);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        this.nodes[key].isSelected = isSelected;\n        this.nodes[key].isIndeterminate = false;\n        changed.set(key, isSelected);\n      }\n      var _iterator5 = _createForOfIteratorHelper(changed.entries()),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n            _key = _step5$value[0],\n            value = _step5$value[1];\n          this.updateVnodeState(_key);\n          if (this.selectionType === 'leaf' && this.isParent(_key)) continue;\n          value === true ? this.selectedCache.add(_key) : this.selectedCache[\"delete\"](_key);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    },\n    updateOpen: function updateOpen(key, isOpen) {\n      var _this9 = this;\n      if (!this.nodes.hasOwnProperty(key)) return;\n      var node = this.nodes[key];\n      var children = getObjectValueByPath(node.item, this.itemChildren);\n      if (children && !children.length && node.vnode && !node.vnode.hasLoaded) {\n        node.vnode.checkChildren().then(function () {\n          return _this9.updateOpen(key, isOpen);\n        });\n      } else if (children && children.length) {\n        node.isOpen = isOpen;\n        node.isOpen ? this.openCache.add(key) : this.openCache[\"delete\"](key);\n        this.updateVnodeState(key);\n      }\n    },\n    updateVnodeState: function updateVnodeState(key) {\n      var node = this.nodes[key];\n      if (node && node.vnode) {\n        node.vnode.isSelected = node.isSelected;\n        node.vnode.isIndeterminate = node.isIndeterminate;\n        node.vnode.isActive = node.isActive;\n        node.vnode.isOpen = node.isOpen;\n      }\n    },\n    isExcluded: function isExcluded(key) {\n      return !!this.search && this.excludedItems.has(key);\n    }\n  },\n  render: function render(h) {\n    var _this10 = this;\n    var children = this.items.length ? this.items.filter(function (item) {\n      return !_this10.isExcluded(getObjectValueByPath(item, _this10.itemKey));\n    }).map(function (item) {\n      var genChild = VTreeviewNode.options.methods.genChild.bind(_this10);\n      return genChild(item, _this10.disabled || getObjectValueByPath(item, _this10.itemDisabled));\n    })\n    /* istanbul ignore next */ : this.$slots[\"default\"]; // TODO: remove type annotation with TS 3.2\n\n    return h('div', {\n      staticClass: 'v-treeview',\n      \"class\": _objectSpread({\n        'v-treeview--hoverable': this.hoverable,\n        'v-treeview--dense': this.dense\n      }, this.themeClasses)\n    }, children);\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}