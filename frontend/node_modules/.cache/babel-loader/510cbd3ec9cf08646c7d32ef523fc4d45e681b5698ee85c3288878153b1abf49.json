{"ast":null,"code":"import _objectSpread from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Admin/Desktop/pomoika vape lab/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport { camelize, wrapInArray } from './helpers';\nvar pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\nfunction parseStyle(style) {\n  var styleMap = {};\n  var _iterator = _createForOfIteratorHelper(style.split(pattern.styleList)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var s = _step.value;\n      var _s$split = s.split(pattern.styleProp),\n        _s$split2 = _slicedToArray(_s$split, 2),\n        key = _s$split2[0],\n        val = _s$split2[1];\n      key = key.trim();\n      if (!key) {\n        continue;\n      } // May be undefined if the `key: value` pair is incomplete.\n\n      if (typeof val === 'string') {\n        val = val.trim();\n      }\n      styleMap[camelize(key)] = val;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return styleMap;\n}\nexport default function mergeData() {\n  var mergeTarget = {};\n  var i = arguments.length;\n  var prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (var _i = 0, _Object$keys = Object.keys(arguments[i]); _i < _Object$keys.length; _i++) {\n      prop = _Object$keys[_i];\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          mergeTarget[prop] = _objectSpread(_objectSpread({}, arguments[i][prop]), mergeTarget[prop]);\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n      }\n    }\n  }\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners() {\n  if (!(arguments.length <= 0 ? undefined : arguments[0])) return arguments.length <= 1 ? undefined : arguments[1];\n  if (!(arguments.length <= 1 ? undefined : arguments[1])) return arguments.length <= 0 ? undefined : arguments[0];\n  var dest = {};\n  for (var i = 2; i--;) {\n    var arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    for (var event in arg) {\n      if (!arg[event]) continue;\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n  return dest;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}